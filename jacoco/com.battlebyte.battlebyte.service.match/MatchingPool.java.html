<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MatchingPool.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BattleByte</a> &gt; <a href="index.source.html" class="el_package">com.battlebyte.battlebyte.service.match</a> &gt; <span class="el_source">MatchingPool.java</span></div><h1>MatchingPool.java</h1><pre class="source lang-java linenums">package com.battlebyte.battlebyte.service.match;

import com.battlebyte.battlebyte.config.BeanContext;
import com.battlebyte.battlebyte.entity.Game;
import com.battlebyte.battlebyte.entity.UserGameRecord;
import com.battlebyte.battlebyte.service.GameService;
import com.battlebyte.battlebyte.service.OJService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.locks.ReentrantLock;

import static com.battlebyte.battlebyte.service.MatchService.returnMatchResult;

/**
 * 匹配池
 */
@Configurable
public class MatchingPool extends Thread {

    private GameService gameService;
    private OJService ojService;
<span class="fc" id="L27">    private static List&lt;Player&gt; royalePlayers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L28">    private static List&lt;Player&gt; oneToOnePlayers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L29">    private ReentrantLock lock = new ReentrantLock();</span>
    private static RestTemplate restTemplate;

<span class="fc" id="L32">    public MatchingPool() {</span>
<span class="fc" id="L33">        this.gameService = BeanContext.getApplicationContext().getBean(GameService.class);</span>
<span class="fc" id="L34">        this.ojService = BeanContext.getApplicationContext().getBean(OJService.class);</span>
<span class="fc" id="L35">    }</span>

    //排序
<span class="fc" id="L38">    private Comparator&lt;Player&gt; playerComparator = new Comparator&lt;Player&gt;() {</span>
        @Override
        public int compare(Player p1, Player p2) {
            // 根据Player对象的变量i进行比较
<span class="nc" id="L42">            return Double.compare(p1.getRating() * 0.1 + p1.getWaitingTime() * 50, p2.getRating() * 0.1 + p2.getWaitingTime() * 50);</span>
        }
    };

    //单人模式
    public void addPlayer1(Integer userId, Integer botId, Integer rating) {
<span class="nc" id="L48">        lock.lock();</span>
        try {
<span class="nc" id="L50">            oneToOnePlayers.add(new Player(userId, rating, 0));</span>
        } finally {
<span class="nc" id="L52">            lock.unlock();</span>
        }
<span class="nc" id="L54">    }</span>

    //大逃杀模式
    public void addPlayer2(Integer userId, Integer botId, Integer rating) {
<span class="nc" id="L58">        lock.lock();</span>
        try {
<span class="nc" id="L60">            royalePlayers.add(new Player(userId, rating, 0));</span>
        } finally {
<span class="nc" id="L62">            lock.unlock();</span>
        }
<span class="nc" id="L64">    }</span>

    /**
     * 在匹配池中删除一个玩家
     *
     * @param userId
     */
    public void removePlayer(Integer userId) {
<span class="nc" id="L72">        lock.lock();</span>
        try {
            //删除1v1模式
<span class="nc" id="L75">            List&lt;Player&gt; newPlayers1 = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">            for (Player player : oneToOnePlayers) {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">                if (!player.getUserId().equals(userId)) {</span>
<span class="nc" id="L78">                    newPlayers1.add(player);</span>
                }
<span class="nc" id="L80">            }</span>
<span class="nc" id="L81">            oneToOnePlayers = newPlayers1;</span>

            //删除大逃杀模式
<span class="nc" id="L84">            List&lt;Player&gt; newPlayers2 = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">            for (Player player : royalePlayers) {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">                if (!player.getUserId().equals(userId)) {</span>
<span class="nc" id="L87">                    newPlayers2.add(player);</span>
                }
<span class="nc" id="L89">            }</span>
<span class="nc" id="L90">            royalePlayers = newPlayers2;</span>
        } finally {
<span class="nc" id="L92">            lock.unlock();</span>
        }
<span class="nc" id="L94">    }</span>

    /**
     * 线程的作用：每秒钟匹配一下所有玩家
     */
    @Override
    public void run() {
        while (true) {
            try {
<span class="nc" id="L103">                Thread.sleep(1000);</span>
<span class="nc" id="L104">                lock.lock();</span>

<span class="nc" id="L106">                System.out.println(&quot;current 1v1 pool players num:&quot; + oneToOnePlayers.size());</span>
<span class="nc" id="L107">                System.out.println(&quot;current Royale pool players num:&quot; + royalePlayers.size());</span>
                try {
<span class="nc" id="L109">                    increaseWaitingTime();</span>
<span class="nc" id="L110">                    matchPlayersOneVsOne();</span>
<span class="nc" id="L111">                    matchPlayersRoyale();</span>
<span class="nc" id="L112">                } catch (IOException e) {</span>
<span class="nc" id="L113">                    throw new RuntimeException(e);</span>
                } finally {
<span class="nc" id="L115">                    lock.unlock();</span>
                }
<span class="nc" id="L117">            } catch (InterruptedException e) {</span>
<span class="nc" id="L118">                e.printStackTrace();</span>
<span class="nc" id="L119">                break;</span>
<span class="nc" id="L120">            }</span>
        }
<span class="nc" id="L122">    }</span>

    //获取1v1匹配
    public int getCurrentMatch() {
<span class="nc" id="L126">        return oneToOnePlayers.size();</span>
    }

    // 将所有当前玩家的等待时间加1
    private void increaseWaitingTime() {
<span class="nc bnc" id="L131" title="All 2 branches missed.">        for (Player player : oneToOnePlayers) {</span>
<span class="nc" id="L132">            player.setWaitingTime(player.getWaitingTime() + 1);</span>
<span class="nc" id="L133">        }</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        for (Player player : royalePlayers) {</span>
<span class="nc" id="L135">            player.setWaitingTime(player.getWaitingTime() + 1);</span>
<span class="nc" id="L136">        }</span>
<span class="nc" id="L137">    }</span>

    // 尝试匹配所有玩家
    // 等待时间长的玩家优先进行匹配
    // 由于存储所有玩家的是list集合，因此下标小的等待时间一定更长
    private void matchPlayersOneVsOne() throws IOException {
<span class="nc" id="L143">        ojService.updateProblems();</span>
<span class="nc" id="L144">        boolean[] used = new boolean[oneToOnePlayers.size()]; // 当前玩家是否匹配</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        for (int i = 0; i &lt; oneToOnePlayers.size(); i++) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">            if (used[i]) continue;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            for (int j = i + 1; j &lt; oneToOnePlayers.size(); j++) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (used[j]) continue;</span>
<span class="nc" id="L149">                Player a = oneToOnePlayers.get(i), b = oneToOnePlayers.get(j);</span>
<span class="nc bnc" id="L150" title="All 4 branches missed.">                if (checkMatched(a, b) &amp;&amp; !a.getUserId().equals(b.getUserId())) {</span>
<span class="nc" id="L151">                    used[i] = used[j] = true;</span>
<span class="nc" id="L152">                    Random random = new Random();</span>
<span class="nc" id="L153">                    Object[] values = ojService.problems.keySet().toArray();</span>
<span class="nc" id="L154">                    int randomIndex = random.nextInt(values.length);</span>
<span class="nc" id="L155">                    int randomQuestionId1 = (int) values[randomIndex];</span>
//                    int randomQuestionId2 = random.nextInt(50) + 1;
<span class="nc" id="L157">                    ArrayList&lt;Player&gt; players = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L158">                    players.add(a);</span>
<span class="nc" id="L159">                    players.add(b);</span>

<span class="nc" id="L161">                    ArrayList&lt;Integer&gt; questionIds = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L162">                    questionIds.add(randomQuestionId1);</span>
<span class="nc" id="L163">                    questionIds.add(randomQuestionId1);</span>


<span class="nc" id="L166">                    sendResult(players, questionIds); // 匹配成功之后返回结果</span>
<span class="nc" id="L167">                    break;</span>
                }
            }
        }

        // 匹配成功的需要从匹配池中剔除
<span class="nc" id="L173">        List&lt;Player&gt; newPlayers = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        for (int i = 0; i &lt; oneToOnePlayers.size(); i++) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (!used[i]) {</span>
<span class="nc" id="L176">                newPlayers.add(oneToOnePlayers.get(i));</span>
            }
        }
<span class="nc" id="L179">        oneToOnePlayers = newPlayers;</span>
<span class="nc" id="L180">    }</span>

    //匹配大逃杀模式
    private void matchPlayersRoyale() throws IOException {
<span class="nc" id="L184">        ojService.updateProblems();</span>

        //排序
<span class="nc" id="L187">        Collections.sort(royalePlayers, Collections.reverseOrder(playerComparator));</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        while (royalePlayers.size() &gt;= 8) {</span>
<span class="nc" id="L189">            Collections.sort(royalePlayers, Collections.reverseOrder(playerComparator));</span>
<span class="nc" id="L190">            List&lt;Player&gt; first8Players = royalePlayers.subList(0, 8);</span>
            //用户
<span class="nc" id="L192">            ArrayList&lt;Player&gt; players = new ArrayList&lt;&gt;();</span>
            //题目
<span class="nc" id="L194">            ArrayList&lt;Integer&gt; questionIds = new ArrayList&lt;&gt;();</span>
            //随机
<span class="nc" id="L196">            Random random = new Random();</span>
<span class="nc" id="L197">            Object[] values = ojService.problems.values().toArray();</span>
<span class="nc" id="L198">            int randomIndex = random.nextInt(values.length);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            for (Player player : first8Players) {</span>
<span class="nc" id="L200">                players.add(player);</span>
<span class="nc" id="L201">                int randomQuestionId = (int) values[randomIndex];</span>
<span class="nc" id="L202">                questionIds.add(randomQuestionId);</span>
<span class="nc" id="L203">            }</span>
            //匹配完成
<span class="nc" id="L205">            sendResult(players, questionIds);</span>
            //清除
<span class="nc" id="L207">            royalePlayers.subList(0, 8).clear();</span>
<span class="nc" id="L208">        }</span>
<span class="nc" id="L209">    }</span>

    // 判断两名玩家是否匹配
    // 根据战力差&lt;=等待时间差*10进行匹配
    private boolean checkMatched(Player a, Player b) {
<span class="nc" id="L214">        int ratingDelta = Math.abs(a.getRating() - b.getRating()); // 战力差距</span>
<span class="nc" id="L215">        int ratingTime = Math.min(a.getWaitingTime(), b.getWaitingTime()); // 最小等待时间</span>
<span class="nc" id="L216">        return true;</span>
    }

    // 返回匹配结果
    private void sendResult(ArrayList&lt;Player&gt; players, ArrayList&lt;Integer&gt; questionIds) throws IOException {
<span class="nc" id="L221">        System.out.println(&quot;send result: &quot; + players.get(0).getUserId() + &quot; &quot; + players.get(1).getUserId());</span>
<span class="nc" id="L222">        int num = players.size();</span>

        // Game加入数据库
<span class="nc" id="L225">        Game game = new Game();</span>
<span class="nc" id="L226">        game.setGameType(0);</span>
<span class="nc" id="L227">        gameService.addGame(game);</span>

        // UserGameRecord加入数据库
<span class="nc bnc" id="L230" title="All 2 branches missed.">        for (int i = 0; i &lt; num; i++) {</span>
<span class="nc" id="L231">            UserGameRecord userGameRecord = new UserGameRecord();</span>
<span class="nc" id="L232">            userGameRecord.setUserId(players.get(i).getUserId());</span>
<span class="nc" id="L233">            userGameRecord.setQuestionId(questionIds.get(i));</span>
<span class="nc" id="L234">            userGameRecord.setGameId(game.getId());</span>
<span class="nc" id="L235">            userGameRecord.setTeam(i); //todo:多人修改逻辑</span>
<span class="nc" id="L236">            gameService.save(userGameRecord);</span>
        }

        // 返回
<span class="nc" id="L240">        Map&lt;String, Integer&gt; playerMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        for (int i = 0; i &lt; num; i++) {</span>
<span class="nc" id="L242">            playerMap.put(Integer.toString(i), players.get(i).getUserId());</span>
        }
<span class="nc bnc" id="L244" title="All 2 branches missed.">        for (int i = 0; i &lt; num; i++) {</span>
<span class="nc" id="L245">            returnMatchResult(players.get(i).getUserId(), questionIds.get(i), playerMap, game.getId());</span>
        }
<span class="nc" id="L247">    }</span>

    public static void main(String[] args) throws IOException {
<span class="nc" id="L250">        MatchingPool matchingPool = new MatchingPool();</span>
<span class="nc" id="L251">        matchingPool.matchPlayersOneVsOne();</span>
<span class="nc" id="L252">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>